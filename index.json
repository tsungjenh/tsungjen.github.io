[{"categories":["Kafka"],"contents":"","permalink":"https://tsungjenh.github.io/blog/consumer_in_kafka/","tags":["Go","Kafka"],"title":"Introducing the Kafka Consumer: Examples with Golang"},{"categories":["Go"],"contents":"","permalink":"https://tsungjenh.github.io/blog/gc_go/","tags":["Go","Garbage Collection"],"title":"Garbage Collection in Go"},{"categories":["Go"],"contents":" Intro There are two classic methods in Go to handle concurrency. One is WaitGroup, the another one is our topic Context. In this article, we are going to explore the source code and see how it works behind the scenes. After the source code review, we will gain more insight of how to use Context properly.\n source code: src/context/context.go   Interface First, Let look at the interface\ntype Context interface { Deadline() (deadline time.Time, ok bool) Done() \u0026lt;-chan struct{} Err() error Value(key interface{}) interface{} } There are 4 methods for this interface.\n Deadline: Deadline is a method to get the deadline of the context. When deadline is due, \u0008the context will raise a cancellation automatically. The second return value ok is to indicate whether the context has a deadline or not. If ok equals false, there is no deadline for the context Done: Done is a method to get a read-only channel. We can read the channel and wait for the parent context to raise the cancellation Err: Err returns the reason to cancel Value: To get the value binded on the context. (We can bind the value to the context with a key)  There is a basic implimentation, emptyCtx, for Context and 2 objects are initiated to use, Background and TODO.\n// An emptyCtx is never canceled, has no values, and has no deadline. It is not // struct{}, since vars of this type must have distinct addresses. type emptyCtx int func (*emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (*emptyCtx) Done() \u0026lt;-chan struct{} { return nil } func (*emptyCtx) Err() error { return nil } func (*emptyCtx) Value(key interface{}) interface{} { return nil } func (e *emptyCtx) String() string { switch e { case background: return \u0026#34;context.Background\u0026#34; case todo: return \u0026#34;context.TODO\u0026#34; } return \u0026#34;unknown empty Context\u0026#34; } var ( background = new(emptyCtx) todo = new(emptyCtx) ) // Background returns a non-nil, empty Context. It is never canceled, has no // values, and has no deadline. It is typically used by the main function, // initialization, and tests, and as the top-level Context for incoming // requests. func Background() Context { return background } // TODO returns a non-nil, empty Context. Code should use context.TODO when // it\u0026#39;s unclear which Context to use or it is not yet available (because the // surrounding function has not yet been extended to accept a Context // parameter). func TODO() Context { return todo } We can see emptyCtx do nothing. All the methods simply return nil. We can not set the deadline, cancel or bind the value to the Context.\nTODO is temporary used when we are not sure which Context implimentation we want to use.\nBackground is a used as a root Context and to create the child Context with following 4 functions.\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc) func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) func WithValue(parent Context, key, val interface{}) Context Let\u0026rsquo;s go through the functions one by one.\n WithCacnel func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { if parent == nil { panic(\u0026#34;cannot create context from nil parent\u0026#34;) } c := newCancelCtx(parent) propagateCancel(parent, \u0026amp;c) return \u0026amp;c, func() { c.cancel(true, Canceled) } } // newCancelCtx returns an initialized cancelCtx. func newCancelCtx(parent Context) cancelCtx { return cancelCtx{Context: parent} } // A cancelCtx can be canceled. When canceled, it also cancels any children // that implement canceler. type cancelCtx struct { Context mu sync.Mutex // protects following fields \tdone chan struct{} // created lazily, closed by first cancel call \tchildren map[canceler]struct{} // set to nil by the first cancel call \terr error // set to non-nil by the first cancel call } WithCancel will receive a parent context and return a cancelCtx object along with a cancel function. In the function we will\n first create a cancelCtx call propagateCancel to arrange this context to be canceled when parent is canceled.  A cancelCtx has a\n Context to point to its parent mutex to ensure thread-safe property (lock the context when we r/w the context), done to push the cacnel signal children to store its future children (this context can futhur be a parent context) err to store the reason when it is canceled.  func (c *cancelCtx) Value(key interface{}) interface{} { if key == \u0026amp;cancelCtxKey { return c } return c.Context.Value(key) } func (c *cancelCtx) Done() \u0026lt;-chan struct{} { c.mu.Lock() if c.done == nil { c.done = make(chan struct{}) } d := c.done c.mu.Unlock() return d } func (c *cancelCtx) Err() error { c.mu.Lock() err := c.err c.mu.Unlock() return err } The implementation is quite simple and the lock makes it thread-safe\nAfter a look to cancelCtx, let\u0026rsquo;s see propagateCancel function.\nfunc propagateCancel(parent Context, child canceler) { done := parent.Done() if done == nil { return // parent is never canceled \t} select { case \u0026lt;-done: // parent is already canceled \tchild.cancel(false, parent.Err()) return default: } if p, ok := parentCancelCtx(parent); ok { p.mu.Lock() if p.err != nil { // parent has already been canceled \tchild.cancel(false, p.err) } else { if p.children == nil { p.children = make(map[canceler]struct{}) } p.children[child] = struct{}{} } p.mu.Unlock() } else { atomic.AddInt32(\u0026amp;goroutines, +1) go func() { select { case \u0026lt;-parent.Done(): child.cancel(false, parent.Err()) case \u0026lt;-child.Done(): } }() } } What propagateCancel does is to\n check parent is already canceled (parent can be canceled, meanwhile, we call WithCancel function). If its parent is canceled, cancel itself as well. If parent is not canceled. Check if parent is cancelCtx, if yes add itself as its parent\u0026rsquo;s child. Otherwise, start a go routine to listen to a done signal and see if its parent is done (the goroutine will trigger the cacnellation when parent is done).   WithDeadline func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { if parent == nil { panic(\u0026#34;cannot create context from nil parent\u0026#34;) } if cur, ok := parent.Deadline(); ok \u0026amp;\u0026amp; cur.Before(d) { // The current deadline is already sooner than the new one. \treturn WithCancel(parent) } c := \u0026amp;timerCtx{ cancelCtx: newCancelCtx(parent), deadline: d, } propagateCancel(parent, c) dur := time.Until(d) if dur \u0026lt;= 0 { c.cancel(true, DeadlineExceeded) // deadline has already passed \treturn c, func() { c.cancel(false, Canceled) } } c.mu.Lock() defer c.mu.Unlock() if c.err == nil { c.timer = time.AfterFunc(dur, func() { c.cancel(true, DeadlineExceeded) }) } return c, func() { c.cancel(true, Canceled) } } WithDeadline returns a copy of the parent context with the deadline adjusted to be no later than d. If the parent\u0026rsquo;s deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned context\u0026rsquo;s Done channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context\u0026rsquo;s Done channel is closed, whichever happens first. Let\u0026rsquo;s take a look at timerCtx\ntype timerCtx struct { cancelCtx timer *time.Timer // Under cancelCtx.mu.  deadline time.Time } func (c *timerCtx) Deadline() (deadline time.Time, ok bool) { return c.deadline, true } func (c *timerCtx) String() string { return contextName(c.cancelCtx.Context) + \u0026#34;.WithDeadline(\u0026#34; + c.deadline.String() + \u0026#34; [\u0026#34; + time.Until(c.deadline).String() + \u0026#34;])\u0026#34; } func (c *timerCtx) cancel(removeFromParent bool, err error) { c.cancelCtx.cancel(false, err) if removeFromParent { // Remove this timerCtx from its parent cancelCtx\u0026#39;s children. \tremoveChild(c.cancelCtx.Context, c) } c.mu.Lock() if c.timer != nil { c.timer.Stop() c.timer = nil } c.mu.Unlock() } timerCtx is built on cancelCtx, it has\n cancelCtx created with its parent. It takes care of the cancellation process. deadline to store a deadline, we can get it by calling Deadline method.   The cancellation is quite the same as cancelCtx except it needs to stop the timer when cancellation is triggered.   WithTimeout func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } WithTimeout is a the same as WithDeadline. It takes a time.Duration as an input, the deadline will be now + duration.\n WithValue // WithValue returns a copy of parent in which the value associated with key is // val. // // Use context Values only for request-scoped data that transits processes and // APIs, not for passing optional parameters to functions. // // The provided key must be comparable and should not be of type // string or any other built-in type to avoid collisions between // packages using context. Users of WithValue should define their own // types for keys. To avoid allocating when assigning to an // interface{}, context keys often have concrete type // struct{}. Alternatively, exported context key variables\u0026#39; static // type should be a pointer or interface. func WithValue(parent Context, key, val interface{}) Context { if parent == nil { panic(\u0026#34;cannot create context from nil parent\u0026#34;) } if key == nil { panic(\u0026#34;nil key\u0026#34;) } if !reflectlite.TypeOf(key).Comparable() { panic(\u0026#34;key is not comparable\u0026#34;) } return \u0026amp;valueCtx{parent, key, val} } // A valueCtx carries a key-value pair. It implements Value for that key and // delegates all other calls to the embedded Context. type valueCtx struct { Context key, val interface{} } // stringify tries a bit to stringify v, without using fmt, since we don\u0026#39;t // want context depending on the unicode tables. This is only used by // *valueCtx.String(). func stringify(v interface{}) string { switch s := v.(type) { case stringer: return s.String() case string: return s } return \u0026#34;\u0026lt;not Stringer\u0026gt;\u0026#34; } func (c *valueCtx) String() string { return contextName(c.Context) + \u0026#34;.WithValue(type \u0026#34; + reflectlite.TypeOf(c.key).String() + \u0026#34;, val \u0026#34; + stringify(c.val) + \u0026#34;)\u0026#34; } func (c *valueCtx) Value(key interface{}) interface{} { if c.key == key { return c.val } return c.Context.Value(key) } WithValue returns a copy of parent in which the value associated with key is val\nvalueCtx has a\n context point to its parent key, value to store the k-v pair  The lookup for the value is a recursive process. A goroutine will recursively find the key. If the key is not existed in all the nodes. the root (Background) will return a nil (emptyCtx implementation).\n   Noted that valueCtx doesn\u0026rsquo;t ensure the val is thread-safe.\n  Conclusion After we explore the source code of Context. Let\u0026rsquo;s have conclusion belows\n Do not put Context inside the structure. Pass it as a parameter Make the Context the first paramter in a function Do not pass nil when you passing Context. It will cause panic if someone uses nil to create child Context. Pass context.TODO if you dont know what to pass. Use valueCtx properly, pass the required data only (such as request meta data). valueCtx doesn\u0026rsquo;t ensure thread-safe for value, passing unnecessary data may cause dirty data issues. Context itself is thread-safe, feel free pass it to different goroutines.  ","permalink":"https://tsungjenh.github.io/blog/go_context/","tags":["Go","Scheduler"],"title":"Go Context Source Code review"},{"categories":["Go"],"contents":"","permalink":"https://tsungjenh.github.io/blog/go_scheduler/","tags":["Go","Scheduler"],"title":"Go Scheduler"},{"categories":["Kafka"],"contents":"","permalink":"https://tsungjenh.github.io/blog/producer_in_kafka/","tags":["Kafka","Consumer"],"title":"Kafka Producer Deep Dive"},{"categories":["Vim"],"contents":"","permalink":"https://tsungjenh.github.io/blog/vim/","tags":["Vim"],"title":"30 Useful Vim Shortcuts to Make You Productive"},{"categories":["Go"],"contents":"","permalink":"https://tsungjenh.github.io/blog/go_map/","tags":["Go","Map"],"title":"Go Maps Source Code Review"},{"categories":["mysql"],"contents":"","permalink":"https://tsungjenh.github.io/blog/row_lock/","tags":["mysql"],"title":"Locking Rows in MySQL: SELECT FOR UPDATE STATEMENT"},{"categories":["Redis"],"contents":"","permalink":"https://tsungjenh.github.io/blog/redis_storage/","tags":["Redis","Persistence"],"title":"Redis Persistence"},{"categories":["vscode"],"contents":"","permalink":"https://tsungjenh.github.io/blog/vscode/","tags":["vscode","IDE"],"title":"Setup VSCode Environment for Go"},{"categories":["mysql"],"contents":"","permalink":"https://tsungjenh.github.io/blog/mysql_index/","tags":["mysql"],"title":"Understanding MySQL Index"},{"categories":["mysql"],"contents":"","permalink":"https://tsungjenh.github.io/blog/mysql_isolation/","tags":["mysql"],"title":"Understanding Transaction Isolation in InnoDB"},{"categories":["Go"],"contents":"0. Intro With its concurrency properties, Go becomes one of the most popular languages in recent years. In Go concurrency, we have this convenient data structure to communicate between multiple goroutines - Channels. In this article, we are going to dive into the source code and get a deep understanding of it.\n soucre code: src/runtime/chan.go  1. Data Structure First, take a look at the data structure.\ntype hchan struct { qcount uint // total data in the queue \tdataqsiz uint // size of the circular queue \tbuf unsafe.Pointer // points to an array of dataqsiz elements \telemsize uint16 closed uint32 elemtype *_type // element type \tsendx uint // send index \trecvx uint // receive index \trecvq waitq // list of recv waiters \tsendq waitq // list of send waiters  // lock protects all fields in hchan, as well as several \t// fields in sudogs blocked on this channel. \t// \t// Do not change another G\u0026#39;s status while holding this lock \t// (in particular, do not ready a G), as this can deadlock \t// with stack shrinking. \tlock mutex } // and bidirectional linked list type waitq struct { first *sudog last *sudog } // a wrapper of goroutine type sudog struct { // The following fields are protected by the hchan.lock of the \t// channel this sudog is blocking on. shrinkstack depends on \t// this for sudogs involved in channel ops.  g *g next *sudog prev *sudog elem unsafe.Pointer // data element (may point to stack)  // The following fields are never accessed concurrently. \t// For channels, waitlink is only accessed by g. \t// For semaphores, all fields (including the ones above) \t// are only accessed when holding a semaRoot lock.  acquiretime int64 releasetime int64 ticket uint32 // isSelect indicates g is participating in a select, so \t// g.selectDone must be CAS\u0026#39;d to win the wake-up race. \tisSelect bool parent *sudog // semaRoot binary tree \twaitlink *sudog // g.waiting list or semaRoot \twaittail *sudog // semaRoot \tc *hchan // channel } We can separate the channel into three parts, including a ring buffer, two wait queues and a lock.\n Ring buffer(buf) is a space (for the buffer channels) to store the temporary data (for a non-buffered channel, buf points to nil). The sendq and the recvq are two bidirectional linked list of send/recv waiter. The nodes in the waitq are sudog which is a wrapper of goroutines. lock is used to assert mutual exclusive to prevent race condition.  A visualization of the Channel data structure is as below.\n  2. Operations There are only 4 Operations for Channel.\n i. Create a channel ii. Send data to a channel iii. Receive data from a channel iv. Close a channel We will go through all the operations one by one.\ni. Create a channel To create a channel, go compiler translate make state to runtime.makechan\n make(chan interface{}, size) —\u0026gt; runtime.makechan(interface{}, size)\nmake(chan interface{}) —\u0026gt; runtime.makechan(interface{}, 0)\n Create a non-buffer channel is like creating a zero size channel. Take a look at the source code. The process breaks into 3 parts.\n Validate parameters(check if memory size is overflow). Create a ring buffer if size is greater than zero.(buffer channel) Assign value and create a lock  func makechan(t *chantype, size int) *hchan { elem := t.elem // compiler checks this but be safe.  if elem.size \u0026gt;= 1\u0026lt;\u0026lt;16 { throw(\u0026#34;makechan: invalid channel element type\u0026#34;) } if hchanSize%maxAlign != 0 || elem.align \u0026gt; maxAlign { throw(\u0026#34;makechan: bad alignment\u0026#34;) } mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u0026gt; maxAlloc-hchanSize || size \u0026lt; 0 { panic(plainError(\u0026#34;makechan: size out of range\u0026#34;)) } // create channel and allocate ring buffer for buffer channel \tvar c *hchan switch { case mem == 0: // Queue or element size is zero. \tc = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. \tc.buf = c.raceaddr() case elem.ptrdata == 0: // Elements do not contain pointers. \t// Allocate hchan and buf in one call. \tc = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers. \tc = new(hchan) c.buf = mallocgc(mem, elem, true) } // assign value and create lock \tc.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026amp;c.lock, lockRankHchan) if debugChan { print(\u0026#34;makechan: chan=\u0026#34;, c, \u0026#34;; elemsize=\u0026#34;, elem.size, \u0026#34;; dataqsiz=\u0026#34;, size, \u0026#34;\\n\u0026#34;) } return c } ii. Send/Receive data to/from channel Send data to channel First of all, a goroutine will always check if the channel is nil or blocked, if the channel is a nil channel. It will call gopark and will be blocked.forever. If a channel is closed, a panic will occur.\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { if !block { return false } gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } // ....  lock(\u0026amp;c.lock) // noted that always need to lock the channel to access or update channel data  if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } // ... }  Noted: If a channel is not nil, a sender needs to acquire the lock before any r/w to the channel.\n sendq and recv are two wait queues that consist of go routines. If a channel has no available space for buffering (a full channel or a non buffer channel) and a sender comes, the go routine will call gopark and will be blocked until a receiver comes. On the other hand, if a channel has no buffer data (the channel is empty or it is a non buffer channel), a receiver will call gopark and will be blocked until a sender comes.\nIn this case, a sender will always try to dequeue the recvq too see if there is a receiver. If there is a receiver in sendq, the sender will copy the data from it and goready the receiver.\nif sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send \t// directly to the receiver, bypassing the channel buffer (if any). \tsend(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } Second, a sender will check if there is available space for buffering.\nif c.qcount \u0026lt; c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. \tqp := chanbuf(c, c.sendx) if raceenabled { raceacquire(qp) racerelease(qp) } typedmemmove(c.elemtype, qp, ep) c.sendx++ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ unlock(\u0026amp;c.lock) return true } If there no enough space for buffering (a full buffer channel or a non buffer channel) a sender will call gopark and will be blocked until a receiver comes.\n// Block on the channel. Some receiver will complete our operation for us. \tgp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg \t// on gp.waiting where copystack can find it. \tmysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) Receive data from channel First, a receiver will always check if the channel is nil. If it is a nil channel, a receiver will be blocked forever. However, it\u0026rsquo;s a bit different in the case of a closed channel. A receiver can always read the data from a closed channel (even if it is empty) and it will continue to loop the buffer and return the value of the pointer. This is why a receiver will always receive zero value from a closed empty channel\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // raceenabled: don\u0026#39;t need to check ep, as it is always on the stack \t// or is new memory allocated by reflect.  if debugChan { print(\u0026#34;chanrecv: chan=\u0026#34;, c, \u0026#34;\\n\u0026#34;) } if c == nil { if !block { return } gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } // ...  lock(\u0026amp;c.lock) if c.closed != 0 \u0026amp;\u0026amp; c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026amp;c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } The following process is quite similar to the process of a sender. A receiver will always try to dequeue the sendq and check if there is any sender in the queue. If there is a sender in sendq, the receiver will copy the data from it and goready the sender\nif sg := c.sendq.dequeue(); sg != nil { // Found a waiting sender. If buffer is size 0, receive value \t// directly from sender. Otherwise, receive from head of queue \t// and add sender\u0026#39;s value to the tail of the queue (both map to \t// the same buffer slot because the queue is full). \trecv(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true, true } Second, check if there is data in the buffer. If yes, copy the data and return it\nif c.qcount \u0026gt; 0 { // Receive directly from queue \tqp := chanbuf(c, c.recvx) if raceenabled { raceacquire(qp) racerelease(qp) } if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026amp;c.lock) return true, true } If there is no data in the buffer (a non buffer channel or an empty buffer channel) a receiver will call gopark and wait for a sender comes.\n// no sender available: block on this channel. \tgp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg \t// on gp.waiting where copystack can find it. \tmysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil c.recvq.enqueue(mysg) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2)  To summarize the Send/Receive process,\n1. To send/recv to a nil channel, a go routine will be blocked forever.\n2. A send/recv need to acquire the lock before any r/w operations.\n3. To send to a closed channel, sender will panic, and a receiver will always get a data even if the channel is empty.\n4. If a buffer is full or nil, a sender will be blocked. If a buffer is empty or nil, receiver will be blocked.\n5. At most one of the queues (sendq/recvq) will be empty.\n iii. Close channel First, to close a channel, a go routine will check if the channel is nil or closed. A panic will occur in both cases.\n Noted that a lock is required to read the information on the channel.\n func closechan(c *hchan) { if c == nil { panic(plainError(\u0026#34;close of nil channel\u0026#34;)) } lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;close of closed channel\u0026#34;)) } //... } Second, there will be a temporary data structure, gList, to store the remaining node in the sendq/recvq and release the lock quickly.\n// release all readers \tfor { sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = nil if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // release all writers (they will panic) \tfor { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = nil if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026amp;c.lock) Once the lock is released. We can trigger goready for each sudog in the gList (temporary storage for releasing the lock quickly) as the closed channel is ready to be read by receivers.\n// Ready all Gs now that we\u0026#39;ve dropped the channel lock. \tfor !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } Conclusion Below is the comparison of the operations\n    Nil Channel Closed Channel Channel     Close Panic Panic Success   Send Blocked forever Panic Success or blocked   Receive Blocked forever always success success or blocked    ","permalink":"https://tsungjenh.github.io/blog/channel_ds/","tags":["Go","channel"],"title":"Go Channel Source Code Review"}]