[{"categories":["Kafka"],"contents":"","permalink":"https://tsungjenh.github.io/blog/consumer_in_kafka/","tags":["Go","Kafka"],"title":"Introducing the Kafka Consumer: Examples with Golang"},{"categories":["Go"],"contents":"","permalink":"https://tsungjenh.github.io/blog/gc_go/","tags":["Go","Garbage Collection"],"title":"Garbage Collection in Go"},{"categories":["Go"],"contents":"","permalink":"https://tsungjenh.github.io/blog/go_scheduler/","tags":["Go","Scheduler"],"title":"Go Scheduler"},{"categories":["Kafka"],"contents":"","permalink":"https://tsungjenh.github.io/blog/producer_in_kafka/","tags":["Kafka","Consumer"],"title":"Kafka Producer Deep Dive"},{"categories":["Vim"],"contents":"","permalink":"https://tsungjenh.github.io/blog/vim/","tags":["Vim"],"title":"30 Useful Vim Shortcuts to Make You Productive"},{"categories":["Go"],"contents":"","permalink":"https://tsungjenh.github.io/blog/go_map/","tags":["Go","Map"],"title":"Go Maps Source Code Review"},{"categories":["mysql"],"contents":"","permalink":"https://tsungjenh.github.io/blog/row_lock/","tags":["mysql"],"title":"Locking Rows in MySQL: SELECT FOR UPDATE STATEMENT"},{"categories":["Redis"],"contents":"","permalink":"https://tsungjenh.github.io/blog/redis_storage/","tags":["Redis","Persistence"],"title":"Redis Persistence"},{"categories":["vscode"],"contents":"","permalink":"https://tsungjenh.github.io/blog/vscode/","tags":["vscode","IDE"],"title":"Setup VSCode Environment for Go"},{"categories":["mysql"],"contents":"","permalink":"https://tsungjenh.github.io/blog/mysql_index/","tags":["mysql"],"title":"Understanding MySQL Index"},{"categories":["mysql"],"contents":"","permalink":"https://tsungjenh.github.io/blog/mysql_isolation/","tags":["mysql"],"title":"Understanding Transaction Isolation in InnoDB"},{"categories":["Go"],"contents":"0. Intro With its concurrency properties, Go becomes one of the most popular languages in recent years. In Go concurrency, we have this convenient data structure to communicate between multiple goroutines - Channels. In this article, we are going to dive into the source code and have a deep understanding of it.\n soucre code from src/runtime/chan.go  1. Data Structure First, let\u0026rsquo;s take a look at the data structure.\ntype hchan struct { qcount uint // total data in the queue \tdataqsiz uint // size of the circular queue \tbuf unsafe.Pointer // points to an array of dataqsiz elements \telemsize uint16 closed uint32 elemtype *_type // element type \tsendx uint // send index \trecvx uint // receive index \trecvq waitq // list of recv waiters \tsendq waitq // list of send waiters  // lock protects all fields in hchan, as well as several \t// fields in sudogs blocked on this channel. \t// \t// Do not change another G\u0026#39;s status while holding this lock \t// (in particular, do not ready a G), as this can deadlock \t// with stack shrinking. \tlock mutex } // and bidirectional linked list type waitq struct { first *sudog last *sudog } // a wrapper of goroutine type sudog struct { // The following fields are protected by the hchan.lock of the \t// channel this sudog is blocking on. shrinkstack depends on \t// this for sudogs involved in channel ops.  g *g next *sudog prev *sudog elem unsafe.Pointer // data element (may point to stack)  // The following fields are never accessed concurrently. \t// For channels, waitlink is only accessed by g. \t// For semaphores, all fields (including the ones above) \t// are only accessed when holding a semaRoot lock.  acquiretime int64 releasetime int64 ticket uint32 // isSelect indicates g is participating in a select, so \t// g.selectDone must be CAS\u0026#39;d to win the wake-up race. \tisSelect bool parent *sudog // semaRoot binary tree \twaitlink *sudog // g.waiting list or semaRoot \twaittail *sudog // semaRoot \tc *hchan // channel } We can separate channel into three parts. A ring buffer, two wait queues, and a lock.\n A ring buffer(buf) is a space (for the buffer channels) to store the temporary data (for a non-buffered channel, buf points to nil). The sendq and the recvq are two bidirectional linked list of send/recv waiter. The nodes in the waitq are sudog which is a wrapper of goroutines. A lock is to assert mutual exclusive to prevent race condition.  A visualization of the Channel data structure as below.\n  2. Operations There are only 4 Operations for channel.\n i. Create a channel ii. Push data into channel iii. Receive data from channel iv. Close a channel We will go through all the operations one by one.\ni. Create a channel To create a channel, go compiler translate make state to runtime.makechan\n make(chan interface{}, size) —\u0026gt; runtime.makechan(interface{}, size)\nmake(chan interface{}) —\u0026gt; runtime.makechan(interface{}, 0)\n To create a non-buffer channel is actually to create a zero size channel. Let\u0026rsquo;s take a look at the source code. The process break into 3 parts.\n validate params(check if mem size overflow). create ring buffer if size greater than 0.(buffer channel) assign value and create lock  func makechan(t *chantype, size int) *hchan { elem := t.elem // compiler checks this but be safe.  if elem.size \u0026gt;= 1\u0026lt;\u0026lt;16 { throw(\u0026#34;makechan: invalid channel element type\u0026#34;) } if hchanSize%maxAlign != 0 || elem.align \u0026gt; maxAlign { throw(\u0026#34;makechan: bad alignment\u0026#34;) } mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u0026gt; maxAlloc-hchanSize || size \u0026lt; 0 { panic(plainError(\u0026#34;makechan: size out of range\u0026#34;)) } // create channel and allocate ring buffer for buffer channel \tvar c *hchan switch { case mem == 0: // Queue or element size is zero. \tc = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. \tc.buf = c.raceaddr() case elem.ptrdata == 0: // Elements do not contain pointers. \t// Allocate hchan and buf in one call. \tc = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers. \tc = new(hchan) c.buf = mallocgc(mem, elem, true) } // assign value and create lock \tc.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026amp;c.lock, lockRankHchan) if debugChan { print(\u0026#34;makechan: chan=\u0026#34;, c, \u0026#34;; elemsize=\u0026#34;, elem.size, \u0026#34;; dataqsiz=\u0026#34;, size, \u0026#34;\\n\u0026#34;) } return c } ii. Send/Receive data to/from channel To send data First of all, a goroutine will always check if the channel is nil or blocked. If the channel is a nil channel. It will call gopark and be blocked.forever. If a channel is closed, a panic is occured.\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { if !block { return false } gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } // ....  lock(\u0026amp;c.lock) // noted that always need to lock the channel to access or update channel data  if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } // ... }  Noted: If a channel is not nil, a sender need to acquire the lock before any r/w to the channel.\n sendq and recv are two wait queues that consist of go routines. If a channel has no available space to buffer(full channel, non buffer channel) and a sender is coming. The go routine will call gopark and be blocked until there is a receiver. On the other hand, if a channel has no buffer data(channel is empty or a non buffer channel), a receiver will call gopark and blocked until a sender is coming.\nIn this case, a sender will always try dequeue recvq if there is a receiver. If there is a receiver in sendq, the sender will copy the data from it and goready it.\nif sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send \t// directly to the receiver, bypassing the channel buffer (if any). \tsend(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } Next, a sender will check if there is available space to buffer.\nif c.qcount \u0026lt; c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. \tqp := chanbuf(c, c.sendx) if raceenabled { raceacquire(qp) racerelease(qp) } typedmemmove(c.elemtype, qp, ep) c.sendx++ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ unlock(\u0026amp;c.lock) return true } If there no available space to buffer(full buffer channel, non buffer channel). A sender will call gopark and be blocked until a receiver is coming.\n// Block on the channel. Some receiver will complete our operation for us. \tgp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg \t// on gp.waiting where copystack can find it. \tmysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) To receive data First, a receiver will always check if the channel is nil. If it is a nil channel, a receiver will be blocked forever. It\u0026rsquo;s a bit different for the case of closed channel, a receiver can always read data from a closed channel(even it is empty). It will continue to loop the buffer and return the value of the pointer, this is the reason why a receiver will always receive zero value from a closed empty channel.\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // raceenabled: don\u0026#39;t need to check ep, as it is always on the stack \t// or is new memory allocated by reflect.  if debugChan { print(\u0026#34;chanrecv: chan=\u0026#34;, c, \u0026#34;\\n\u0026#34;) } if c == nil { if !block { return } gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } // ...  lock(\u0026amp;c.lock) if c.closed != 0 \u0026amp;\u0026amp; c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026amp;c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } The following process is quite similar to the process of sender. A receiver will try dequeue sendq and check if there is any sender in the queue. If there is a sender in sendq, the receiver will copy the data from it and goready it.\nif sg := c.sendq.dequeue(); sg != nil { // Found a waiting sender. If buffer is size 0, receive value \t// directly from sender. Otherwise, receive from head of queue \t// and add sender\u0026#39;s value to the tail of the queue (both map to \t// the same buffer slot because the queue is full). \trecv(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true, true } Next, to see if there is data in the buffer. If yes, copy the data and return.\nif c.qcount \u0026gt; 0 { // Receive directly from queue \tqp := chanbuf(c, c.recvx) if raceenabled { raceacquire(qp) racerelease(qp) } if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026amp;c.lock) return true, true } If there is no data in the buffer(non buffer channel, empty buffer channel). A receiver will call gopark and wait for the sending coming.\n// no sender available: block on this channel. \tgp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg \t// on gp.waiting where copystack can find it. \tmysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil c.recvq.enqueue(mysg) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2)  To summarize the send/recv,\n1. To recv/send to a nil channel, a go routine will be blocked forever.\n2. A send/recv need to acquire the lock before any r/w operations.\n3. To send to a closed channel, sender will panic, receiver will always get a data even it is empty.\n4. If buffer is full or nil, sender will be blocked. If buffer is empty or nil, receiver will be blocked.\n5. At most one of the queues(sendq/recvq) will be empty.\n iii. Close channel To close a channel, a go routine will check if the channel is nil or closed. In both cases, a panic will occur. Noted that a lock is required before read the information of channel.\nfunc closechan(c *hchan) { if c == nil { panic(plainError(\u0026#34;close of nil channel\u0026#34;)) } lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;close of closed channel\u0026#34;)) } //... } Next, we will have a temporary datastructure gList to store the remaining node in the sendq/recvq and quick release the lock.\n// release all readers \tfor { sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = nil if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // release all writers (they will panic) \tfor { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = nil if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026amp;c.lock) Once the lock is released. We can trigger goready for each sudog in gList. The gList is a temporary storage in order to quick release the lock. Because a closed channel will be able to be read by receivers.\n// Ready all Gs now that we\u0026#39;ve dropped the channel lock. \tfor !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } Conclusion For all the operations we mentions aforementioned,\n    Nil Channel Closed Channel Channel     Close Panic Panic Success   Send Blocked forever Panic Success or blocked   Receive Blocked forever always success success or blocked    ","permalink":"https://tsungjenh.github.io/blog/channel_ds/","tags":["Go","channel"],"title":"Go Channel Source Code Review"}]