[{"categories":["Go"],"contents":"0. Intro With its concurrency properties, Go becomes one of the most popular languages in recent years. In Go concurrency, we have this convenient data structure to communicate between multiple goroutines - Channels. In this article, we are going to dive into the source code and have a deep understanding of it.\n soucre code from src/runtime/chan.go  1. Data Structure First, let\u0026rsquo;s take a look at the data structure.\ntype hchan struct { qcount uint // total data in the queue \tdataqsiz uint // size of the circular queue \tbuf unsafe.Pointer // points to an array of dataqsiz elements \telemsize uint16 closed uint32 elemtype *_type // element type \tsendx uint // send index \trecvx uint // receive index \trecvq waitq // list of recv waiters \tsendq waitq // list of send waiters  // lock protects all fields in hchan, as well as several \t// fields in sudogs blocked on this channel. \t// \t// Do not change another G\u0026#39;s status while holding this lock \t// (in particular, do not ready a G), as this can deadlock \t// with stack shrinking. \tlock mutex } // and bidirectional linked list type waitq struct { first *sudog last *sudog } // a wrapper of goroutine type sudog struct { // The following fields are protected by the hchan.lock of the \t// channel this sudog is blocking on. shrinkstack depends on \t// this for sudogs involved in channel ops.  g *g next *sudog prev *sudog elem unsafe.Pointer // data element (may point to stack)  // The following fields are never accessed concurrently. \t// For channels, waitlink is only accessed by g. \t// For semaphores, all fields (including the ones above) \t// are only accessed when holding a semaRoot lock.  acquiretime int64 releasetime int64 ticket uint32 // isSelect indicates g is participating in a select, so \t// g.selectDone must be CAS\u0026#39;d to win the wake-up race. \tisSelect bool parent *sudog // semaRoot binary tree \twaitlink *sudog // g.waiting list or semaRoot \twaittail *sudog // semaRoot \tc *hchan // channel } We can separate channel into three parts. A ring buffer, two wait queues, and a lock.\n A ring buffer(buf) is a space (for the buffer channels) to store the temporary data (for a non-buffered channel, buf points to nil). The sendq and the recvq are two bidirectional linked list of send/recv waiter. The nodes in the waitq are sudog which is a wrapper of goroutines. A lock is to assert mutual exclusive to prevent race condition.  A visualization of the Channel data structure as below.\n  2. Operations There are only 4 Operations for channel.\n i. Create a channel ii. Push data into channel iii. Receive data from channel iv. Close a channel We will go through all the operations one by one.\ni. Create a channel To create a channel, go compiler translate make state to runtime.makechan\n make(chan interface{}, size) —\u0026gt; runtime.makechan(interface{}, size)\nmake(chan interface{}) —\u0026gt; runtime.makechan(interface{}, 0)\n To create a non-buffer channel is actually to create a zero size channel. Let\u0026rsquo;s take a look at the source code. The process break into 3 parts.\n validate params(check if mem size overflow). create ring buffer if size greater than 0.(buffer channel) assign value and create lock  func makechan(t *chantype, size int) *hchan { elem := t.elem // compiler checks this but be safe.  if elem.size \u0026gt;= 1\u0026lt;\u0026lt;16 { throw(\u0026#34;makechan: invalid channel element type\u0026#34;) } if hchanSize%maxAlign != 0 || elem.align \u0026gt; maxAlign { throw(\u0026#34;makechan: bad alignment\u0026#34;) } mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u0026gt; maxAlloc-hchanSize || size \u0026lt; 0 { panic(plainError(\u0026#34;makechan: size out of range\u0026#34;)) } // create channel and allocate ring buffer for buffer channel \tvar c *hchan switch { case mem == 0: // Queue or element size is zero. \tc = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. \tc.buf = c.raceaddr() case elem.ptrdata == 0: // Elements do not contain pointers. \t// Allocate hchan and buf in one call. \tc = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers. \tc = new(hchan) c.buf = mallocgc(mem, elem, true) } // assign value and create lock \tc.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026amp;c.lock, lockRankHchan) if debugChan { print(\u0026#34;makechan: chan=\u0026#34;, c, \u0026#34;; elemsize=\u0026#34;, elem.size, \u0026#34;; dataqsiz=\u0026#34;, size, \u0026#34;\\n\u0026#34;) } return c } ii. Send/Receive data to/from channel There are 4 different scenario for the Send/Receive.\n To send:\nCase 1: Send to a buffer channel\nCase 2: Send to a full buffer channel\nCase 3: Send to a non-buffer channel\nfor case 2 and 3 are actually the same process. We will see the detail later.\n  To receive:\nCase 1: Receive from a buffer channel\nCase 2: Receive from a empty buffer channel\nCase 3: Receive from a non-buffer channel\nfor case 2 and 3 are actually the same process. We will see the detail later.\n Case 1. Send to a buffer channel   ","permalink":"https://tsungjenh.github.io/blog/channel_ds/","tags":["Go","channel"],"title":"Go Channel Source Code Review"}]