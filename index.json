[{"categories":["Go"],"contents":"With its concurrency properties, Go becomes one of the most popular languages in recent years. In Go concurrency, we have this convenient data structure to communicate between each goroutine - Channels. In this article, we are going to dive into the source code and have a deep understanding of it.\ntype hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G's status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex } // and bidirectional linked list type waitq struct { first *sudog last *sudog } // a wrapper of goroutine type sudog struct { // The following fields are protected by the hchan.lock of the // channel this sudog is blocking on. shrinkstack depends on // this for sudogs involved in channel ops. g *g next *sudog prev *sudog elem unsafe.Pointer // data element (may point to stack) // The following fields are never accessed concurrently. // For channels, waitlink is only accessed by g. // For semaphores, all fields (including the ones above) // are only accessed when holding a semaRoot lock. acquiretime int64 releasetime int64 ticket uint32 // isSelect indicates g is participating in a select, so // g.selectDone must be CAS'd to win the wake-up race. isSelect bool parent *sudog // semaRoot binary tree waitlink *sudog // g.waiting list or semaRoot waittail *sudog // semaRoot c *hchan // channel } We can separate into three parts. A ring buffer, two wait queues, and a lock.\n A ring buffer defines a space for the buffer channels (for a non-buffered channel, buf points to nil). The sendq and the recvq are two bidirectional linked list of send/recv waiter. TThe sendq and the recvq are two bidirectional linked list of send/recv waiter. The nodes in the waitq are sudog which is a wrapper of goroutines. A lock is to assert mutual exclusive to prevent race condition.  A visualization of the Channel data structure as below.\n  For the operat\n","permalink":"https://tsungjenh.github.io/blog/channel_ds/","tags":["Go","channel"],"title":"Go Channel Source Code Review"}]